// Generated by CoffeeScript 1.11.0
(function() {
  var Conditioner, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  Conditioner = (function() {
    function Conditioner(condition, options) {
      var c, i, key, len, val;
      if (options == null) {
        options = {};
      }
      this.config = _.defaults(options, {
        matchWords: true,
        ignoreCase: true,
        ignorePunctuation: true,
        escapeValues: false
      });
      this.b = this.config.matchWords ? '\\b' : '';
      this.i = this.config.ignoreCase ? 'i' : '';
      this.types = ['is', 'starts', 'ends', 'contains', 'excludes', 'after', 'before', 'range'];
      this.expressions = {};
      if (typeof condition === 'array') {
        for (i = 0, len = condition.length; i < len; i++) {
          c = condition[i];
          this.add(c);
        }
      } else if (typeof condition === 'object') {
        for (key in condition) {
          val = condition[key];
          c = {};
          c[key] = val;
          this.add(c);
        }
      } else if (condition != null) {
        this.add(condition);
      }
    }

    Conditioner.prototype.add = function(condition, key) {
      var type, value;
      if (key == null) {
        key = _.size(this.expressions);
      }
      switch (false) {
        case !_.isRegExp(condition):
          this.expressions[key] = condition;
          break;
        case typeof condition !== 'string':
          this.expressions[key] = this.toRegExp(condition);
          break;
        case typeof condition !== 'object':
          for (type in condition) {
            value = condition[type];
            this.expressions[key] = this.create(type, value);
          }
      }
      return this;
    };

    Conditioner.prototype.toRegExp = function(str) {
      var match, re;
      match = str.match(new RegExp('^/(.+)/(.*)$'));
      if (match) {
        re = new RegExp(match[1], match[2]);
      }
      if (!_.isRegExp(re)) {
        throw new Error(str + " can not converted to RegExp");
      }
      return re;
    };

    Conditioner.prototype.escapeRegExp = function(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    };

    Conditioner.prototype.create = function(type, value) {
      if (typeof value !== 'string') {
        return false;
      }
      if (indexOf.call(this.types, type) < 0) {
        throw new Error(type + " is an invalid condition type");
      }
      if (this.config.escapeValues) {
        value = this.escapeRegExp(value);
      }
      switch (type) {
        case 'is':
          return new RegExp("^(" + value + ")$", this.i);
        case 'starts':
          return new RegExp("^(" + value + ")" + this.b, this.i);
        case 'ends':
          return new RegExp(this.b + "(" + value + ")$", this.i);
        case 'contains':
          return new RegExp(this.b + "(" + value + ")" + this.b, this.i);
        case 'excludes':
          return new RegExp("^((?!" + this.b + value + this.b + ").)*$", this.i);
        case 'after':
          return new RegExp("(?:" + value + "\\s)([\\w\\-]+)", this.i);
        case 'before':
          return new RegExp(this.b + "([\\w\\-]+)(?:\\s" + value + ")", this.i);
        case 'range':
          return new RegExp(this.b + "([" + value + "]|[" + value + "][0-9]|[" + value + "][0-9][0-9])" + this.b, this.i);
      }
    };

    Conditioner.prototype.compare = function(str) {
      if (!_.size(this.expressions)) {
        return false;
      }
      if (this.config.ignorePunctuation) {
        str = str.replace(/[^\w\s]/g, '');
      }
      this.matches = _.mapObject(this.expressions, function(re) {
        return str.match(re);
      });
      this.compared = _.mapObject(this.matches, function(match) {
        return match != null;
      });
      return _.every(_.values(this.compared));
    };

    Conditioner.prototype.capture = function(str) {
      if (!_.size(this.expressions)) {
        return false;
      }
      if (this.config.ignorePunctuation) {
        str = str.replace(/[^\w\s]/g, '');
      }
      this.matches = _.mapObject(this.expressions, function(re) {
        return str.match(re);
      });
      this.captured = _.mapObject(this.matches, function(match) {
        return match != null ? match[1] : void 0;
      });
      if (_.some(this.captured)) {
        return this.captured;
      } else {
        return false;
      }
    };

    Conditioner.prototype.clear = function() {
      delete this.captured;
      delete this.compared;
      return delete this.matches;
    };

    Conditioner.prototype.clearAll = function() {
      this.clear();
      return this.expressions = {};
    };

    return Conditioner;

  })();

  module.exports = Conditioner;

}).call(this);
